namespace {
    const float offsetVal = 1.0 / 300.0;

    vec4 ApplyKernel(std::Texture2d tex, vec2 UV, vec2 offsets[9], float kernel[9]){
        vec4 fragColor = vec4(0.0);

        for(int i = 0; i < 9; ++i){
            fragColor += tex.sample(UV + offsets[i]) * kernel[i];
        }

        fragColor.a = 1.0;

        return fragColor;
    };
}

void MyFunc(inout float kernel[9], float size, float sigma, float lambda, float theta, float psi, float gamma){
    float sigmaX = sigma;
    float sigmaY = sigma / gamma;

    float xMax = max(abs(size * sigmaX * cos(theta)), abs(size * sigmaY * sin(theta)));
    xMax = ceil(max(1.0, xMax));

    float yMax = max(abs(size * sigmaX * sin(theta)), abs(size * sigmaY * cos(theta)));
    yMax = ceil(max(1.0, yMax));

    float xMin = -xMax;
    float yMin = -yMax;

    //List<int> xValues = Matrix.Vector(xMin, xMax, increment: 1);
    //List<int> yValues = Matrix.Vector(yMin, yMax, increment: 1);

    //return new Matrix(xValues.Count, yValues.Count);
}

void Test(inout float kernel[9], float theta){
    float u = 55.0;
    float v = 85.0;

    float pi = 3.14;
    float fmax = 0.25;
    float gamma = sqrt(2.0);
    float eta = sqrt(2.0);

    float fu = fmax / (sqrt(0.6) * sqrt(0.6)); //i - 1
    float alpha = fu/gamma;
    float beta = fu/eta;

    float tetav = theta; //j - 1 //rad

    float m = 3.0;
    float n = 3.0;

    for(float x = 1.0; x <= 3.0; ++x){
        for(float y = 1.0; y <= 3.0; ++y){
            float xprime = (x-((m + 1.0) * 0.5))*cos(tetav)+(y-((n + 1.0) * 0.5)) * sin(tetav);
            float yprime = -(x-((m + 1.0) * 0.5))*sin(tetav)+(y-((n + 1.0) * 0.5)) * cos(tetav);
            kernel[(int(y) - 1) * 3 + (int(x) - 1)] = ((fu * fu) / (pi * gamma * eta)) * exp(-((alpha * alpha) * (xprime * xprime) + (beta * beta) * (yprime * yprime))) * exp(2.0 * pi * fu * xprime);
        }
    }
}

vec4 main(std::Texture2d tex) {
    vec2 offsets[9] = {
	    vec2(-offsetVal, offsetVal),
        vec2(0.0, offsetVal),
        vec2(offsetVal, offsetVal),
        vec2(-offsetVal, 0.0),
        vec2(0.0, 0.0),
        vec2(offsetVal, 0.0),
        vec2(-offsetVal, -offsetVal),
        vec2(0.0, -offsetVal),
        vec2(offsetVal, -offsetVal)
    };

    const float sharpenForce = 2.0;

    float kernel[9];
    //MyFunc(kernel, 3, 8.0, 3.14, pi / 4.0 * 0.0, sqrt(2.0));
    for(float i = 0.0; i <= 5.0; ++i){
        Test(kernel, 3.14 * i / 5.0);
    }

	return ApplyKernel(tex, fragment(std::getVertexTexCoord()), offsets, kernel);
}